- 从redis的应用维度，系统维度角度去理解 
![image](https://user-images.githubusercontent.com/9994537/111073958-dfc87680-851b-11eb-8dd1-8833f7b56d15.png)

# 数据结构
- 整数数组和压缩列表作为底层数据结构的优势是什么？<br>
整数数组和压缩列表的设计，为了节省内存空间。<br>
整数数组和压缩列表都是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。因为元素是挨个连续放置的，我们不用再通过额外的指针把元素串接起来，这就避免了额外指针带来的空间开销。
![image](https://user-images.githubusercontent.com/9994537/111074176-b825de00-851c-11eb-9932-12ddf3899a0f.png)


- 问题：Redis 基本 IO 模型中还有哪些潜在的性能瓶颈？<br>
这个问题是希望你能进一步理解阻塞操作对 Redis 单线程性能的影响。在 Redis 基本 IO 模型中，主要是主线程在执行操作，任何耗时的操作，例如 bigkey、全量返回等操作，都是潜在的性能瓶颈。

- AOF 重写过程中有没有其他潜在的阻塞风险？
这里有两个风险。<br>
风险一：Redis 主线程 fork 创建 bgrewriteaof 子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（Process Control Block，简称为 PCB）。内核要把主线程的 PCB 内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就会长，这就会给主线程带来阻塞风险。<br>
风险二：bgrewriteaof 子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞。

- 问题 2：AOF重写为什么不共享使用AOF本身的日志？<br>
如果都用 AOF 日志的话，主线程要写，bgrewriteaof 子进程也要写，这两者会竞争文件系统的锁，这就会对 Redis 主线程的性能造成影响。

