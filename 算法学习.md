- java常用语法
```
  Deque表示双端队列。双端队列是在两端都可以进行插入和删除的队列。
  常用方法：
  新建一个双端队列：Deque<> deque = new LinkedList<>();
  判断是否为空： deque.isEmpty()
  增：deque.addFirst()， deque.addLast();//从头添加和尾部添加
  删：deque.pollFirst()， deque.pollLast()//从头删除和尾部出队
  查：deque.peekFirst(), deque.peekLast()//查看头添加和尾部元素
  
  Stack栈
  判断是否为空：empty() 
  增：push() //把项压入堆栈顶部。
  删：pop() //移除堆栈顶部的对象，并作为此函数的值返回该对象。
  查：peek() //查看堆栈顶部的对象，但不从堆栈中移除它。
  查：search() //返回对象在堆栈中的位置，以 1 为基数。
  
  queue队列
        抛出异常 　　 返回特殊值
  插入：add(e) 　　   offer(e)  //插入一个元素
  移除：remove()      poll()    //移除和返回队列的头
  检查：element()     peek()    //返回但不移除队列的头。

  获取字符串
  String a = "asd";
  char key = a.charAt(i);

  map 使用
  //是否包含
  if(map.containsKey(key)){}
  // map遍历
  Map<Character, Integer> map = new HashMap();
  for(Integer num:map.values()){}
```

- 哈希表
    - 考察map的使用 
    - [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)
    ``` 
      public boolean isAnagram(String s, String t) {
            if(s.length() != t.length())
                return false;
            int[] alpha = new int[26];
            for(int i = 0; i< s.length(); i++) {
                alpha[s.charAt(i) - 'a'] ++;
                alpha[t.charAt(i) - 'a'] --;
            }
            for(int i=0;i<26;i++)
                if(alpha[i] != 0)
                    return false;
            return true;
        }
    ```  
    - [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)  
    - [两数之和](https://leetcode-cn.com/problems/two-sum/)
      
 - 树
    - [二叉搜索树 Demo](https://visualgo.net/zh/bst)
       - 左子树所有节点小于根结点，右子树大于根节点
    - [前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
       - 递归遍历 
       - 循环遍历
   ```  
     思路：
     我们有一棵二叉树：
            中
           /  \
          左   右
     前序遍历：中，左，右
     中序遍历：左，中，右
     后序遍历：左，右，中
     例如：中序遍历。解释一下为什么需要“右子节点、自身、左子节点依次入栈”
     栈是一种 先进后出的结构，出栈顺序为左，中，右
     那么入栈顺序必须调整为倒序，也就是右，中，左
     同理，如果是前序遍历，入栈顺序为 右，左，中；后序遍历，入栈顺序中，右，左
     // 迭代法-利用栈前序遍历
     public List<Integer> preorderTraversal(TreeNode root) {
         List<Integer> res = new ArrayList();
         Stack<TreeNode> stack = new Stack();
         stack.add(root);
         while(!stack.empty()){
             TreeNode node = stack.pop();
             res.add(node.val);
             if(node.right != null){
                 stack.add(node.right);
             }
             if(node.left != null) {
                 stack.add(node.left);
             }
         }    
         return res; 
     }
     
     // 颜色标记法，通过调整入栈顺序，可以遍历前，中，后序遍历
     public class ColorNode{
         String color;
         TreeNode node;
         ColorNode(TreeNode node, String color){
            this.node = node;
            this.color = color;
         }
     }
     public List<Integer> inorderTraversal(TreeNode root) {
         if(root == null) {
             return new ArrayList();
         }
         List<Integer> res = new ArrayList();
         Stack<ColorNode> stack = new Stack();
         stack.add(new ColorNode(root, "white"));  
         while(! stack.empty()){
             ColorNode cn = stack.pop();
             if(cn.color.equals("white")) {
                 if(cn.node.right != null) stack.add(new ColorNode(cn.node.right, "white"));
                 stack.add(new ColorNode(cn.node, "gray"));
                 if(cn.node.left != null) stack.add(new ColorNode(cn.node.left, "white"));
             } else {
                res.add(cn.node.val);
             }
         }
         return res; 
     }
   ``` 

   - N叉树前序遍历
   ``` 
     前序遍历
     public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList();
        if(root == null){
            return res;
        }
        Deque<Node> deque = new LinkedList();
        deque.add(root);
        while(! deque.isEmpty()){
            Node node = deque.pollLast();
            res.add(node.val);
            Collections.reverse(node.children);
            for(Node item : node.children){
                deque.add(item);
            }
        }
        return res;
     }
   ``` 
   - N叉树后序遍历
   ``` 
     遍历顺序：左右根
     // 递归解法
     public List<Integer> postorder(Node root) {
         if(root == null){
             return new ArrayList();
         }
         List<Integer> res = new ArrayList();
         postordertravesal(root, res);
            return res;
     }
     public void postordertravesal(Node root, List<Integer> res){
        if(root == null){
            return;
        }
        for(int i=0; i<root.children.size(); i++){
            postordertravesal(root.children.get(i), res);
        }
        res.add(root.val);
     }
     
     // 迭代解法，利用双端队列，在头部加入，头部删除，
     public List<Integer> postorder(Node root) {
        if(root == null){
            return new ArrayList();
        }
        List<Integer> res = new ArrayList();
        Deque<Node> deque = new LinkedList();
        deque.add(root);
        while(! deque.isEmpty()){
            Node aa = deque.pollFirst();
            // 这里新加的元素都在前面，
            res.add(0, aa.val);
            for(int i=0; i<aa.children.size(); i++){
                deque.addFirst(aa.children.get(i));
            }
        }
        return res;
    }
   ``` 
   - 对称二叉树
   ```
     // 递归
     public static boolean isSymmetric(TreeNode root){
        if(root == null){
            return false;
        }
        return dfs(root.left, root.right);
     }
     public static boolean dfs(TreeNode left, TreeNode right){
         if(left == null && right == null){
             return true;
         }
         if(left == null || right == null || left.val != right.val){
             return false;
         }
         return dfs(left.left, right.right) && dfs(left.right, right.left);
     }
     // 迭代
     public boolean isSymmetric(TreeNode root) {
        if(root == null || (root.left == null && root.right == null)){
            return true;
        }
        LinkedList<TreeNode> queue = new LinkedList();
        queue.add(root.left);
        queue.add(root.right);
        while(! queue.isEmpty()){
            TreeNode left = queue.pollFirst();
            TreeNode right = queue.pollFirst();
            if(left == null && right == null){
                continue;
            }
            if(left == null || right == null){
                return false;
            }
            if(left.val != right.val){
                return false;
            }
            queue.add(left.left);
            queue.add(right.right);
            queue.add(left.right);
            queue.add(right.left);
        }
        return true;
    }
   ```
